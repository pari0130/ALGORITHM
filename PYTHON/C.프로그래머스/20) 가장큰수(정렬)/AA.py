
'''
int형의 list를 map을 사용하여 string으로 치환한 뒤, list로 변환한다. 
변환된 num을 sort()를 사용하여 key 조건에 맞게 정렬한다. 

lambda x : x*3은 num 인자 각각의 문자열을 3번 반복한다는 뜻이다. 
x*3을 하는 이유? -> num의 인수값이 1000 이하이므로 3자리수로 맞춘 뒤, 비교하겠다는 뜻.
이 문제의 핵심이라고 할 수 있다. 

문자열 비교는 ASCII 값으로 치환되어 정렬된다. 따라서 666, 101010, 222의 첫번째 인덱스 값으로 비교한다. 
6 = 86, 1 = 81, 2 = 82 이므로 6 > 2 > 1순으로 크다. 

sort()의 기본 정렬 기준은 오름차순이다. reverse = True 전의 sort된 결과값은 10, 2, 6이다. 
이를 reverse = True를 통해 내림차순 해주면 6,2,10이 된다. 이것을 ''.join(num)을 통해 문자열을 합쳐주면 된다. 
int로 변환한 뒤, 또 str로 변환해주는 이유?
모든 값이 0일 때(즉, '000'을 처리하기 위해) int로 변환한 뒤, 다시 str로 변환한다. 


출처: https://wooaoe.tistory.com/82 [개발개발 울었다]

이리저리 찾아본걸 정리하자면 다음과 같다.

numbers.sort(key=lambda x: x*3, reverse=True) 

x*3은 문자열을 3번 곱하는 것이므로 "1"이면 "111"이 반환되고 "37"이면 "373737"이 반환된다.

"1","10","100", "1000" 을 비교한다고 가정하자

그러면 "111", "101010", "100100100", "100010001000" 끼리 비교해서 정렬한다.

숫자로만 보면 당연히 맨오른쪽이 크고 맨 왼쪽이 작은게 맞다.

하지만 문자열의 대소 비교는 문자열의 맨 앞(제일 큰자리수,각 숫자별 맨 왼쪽)부터 하게 된다.

ASCII code로 확인하면 "1"은 49이고 "0"은 48이다. 그러면 맨 앞자리 문자열부터 확인해보면

 "111" > "101010" > "100100100"> "100010001000" 이 된다.

그렇기 때문에 1>10>100>100 순이 되고 앞에서부터 추가를 하게되면 가장 큰수가 나온다.

'''

# 숫자, 자리수 10, 100, 1000


def solution(num):
    num = list(map(str, num))
    num.sort(key=lambda x: x * 3, reverse=True)
    return str(int(''.join(num)))


print("답 : ", solution([6, 10, 2]))  # "6210"
print("답 : ", solution([3, 30, 34, 5, 9]))  # "9534330"
print("답 : ", solution([9999, 9998, 3434, 5, 9]))  # "9534330"

# print((123 % 100) // 10)
# print((123 % 10) // 1)
# print((123 % 100) // 100)

# print(423 // 100)
